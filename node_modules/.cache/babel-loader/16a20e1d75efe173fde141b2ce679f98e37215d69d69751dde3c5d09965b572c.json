{"ast":null,"code":"var max = require('lodash/max');\nvar compact = require('lodash/compact');\nvar times = require('lodash/times');\nvar trimStart = require('lodash/trimStart');\nvar padEnd = require('lodash/padEnd');\nvar he = require('he');\nvar helper = require('./helper');\nfunction formatText(elem, options) {\n  var text = elem.data || \"\";\n  text = he.decode(text, options.decodeOptions);\n  if (options.isInPre) {\n    return text;\n  } else {\n    return helper.wordwrap(elem.trimLeadingSpace ? trimStart(text) : text, options);\n  }\n}\nfunction formatImage(elem, options) {\n  if (options.ignoreImage) {\n    return '';\n  }\n  var result = '',\n    attribs = elem.attribs || {};\n  if (attribs.alt) {\n    result += he.decode(attribs.alt, options.decodeOptions);\n    if (attribs.src) {\n      result += ' ';\n    }\n  }\n  if (attribs.src) {\n    result += '[' + attribs.src + ']';\n  }\n  return result;\n}\nfunction formatLineBreak(elem, fn, options) {\n  return '\\n' + fn(elem.children, options);\n}\nfunction formatParagraph(elem, fn, options) {\n  var paragraph = fn(elem.children, options);\n  if (options.singleNewLineParagraphs) {\n    return paragraph + '\\n';\n  } else {\n    return paragraph + '\\n\\n';\n  }\n}\nfunction formatHeading(elem, fn, options) {\n  var heading = fn(elem.children, options);\n  if (options.uppercaseHeadings) {\n    heading = heading.toUpperCase();\n  }\n  return heading + '\\n';\n}\n\n// If we have both href and anchor text, format it in a useful manner:\n// - \"anchor text [href]\"\n// Otherwise if we have only anchor text or an href, we return the part we have:\n// - \"anchor text\" or\n// - \"href\"\nfunction formatAnchor(elem, fn, options) {\n  var href = '';\n  // Always get the anchor text\n  var storedCharCount = options.lineCharCount;\n  var text = fn(elem.children || [], options);\n  if (!text) {\n    text = '';\n  }\n  var result = elem.trimLeadingSpace ? trimStart(text) : text;\n  if (!options.ignoreHref) {\n    // Get the href, if present\n    if (elem.attribs && elem.attribs.href) {\n      href = elem.attribs.href.replace(/^mailto:/, '');\n    }\n    if (href) {\n      if (!options.noAnchorUrl || options.noAnchorUrl && href[0] !== '#') {\n        if (options.linkHrefBaseUrl && href.indexOf('/') === 0) {\n          href = options.linkHrefBaseUrl + href;\n        }\n        if (!options.hideLinkHrefIfSameAsText || href !== helper.replaceAll(result, '\\n', '')) {\n          if (!options.noLinkBrackets) {\n            result += ' [' + href + ']';\n          } else {\n            result += ' ' + href;\n          }\n        }\n      }\n    }\n  }\n  options.lineCharCount = storedCharCount;\n  return formatText({\n    data: result || href,\n    trimLeadingSpace: elem.trimLeadingSpace\n  }, options);\n}\nfunction formatHorizontalLine(elem, fn, options) {\n  return '\\n' + '-'.repeat(options.wordwrap) + '\\n\\n';\n}\nfunction formatListItem(prefix, elem, fn, options) {\n  options = Object.assign({}, options);\n  // Reduce the wordwrap for sub elements.\n  if (options.wordwrap) {\n    options.wordwrap -= prefix.length;\n  }\n  // Process sub elements.\n  var text = fn(elem.children, options);\n  // Replace all line breaks with line break + prefix spacing.\n  text = text.replace(/\\n/g, '\\n' + ' '.repeat(prefix.length));\n  // Add first prefix and line break at the end.\n  return prefix + text + '\\n';\n}\nvar whiteSpaceRegex = /^\\s*$/;\nfunction formatUnorderedList(elem, fn, options) {\n  var result = '';\n  var prefix = options.unorderedListItemPrefix;\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function (child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  });\n  nonWhiteSpaceChildren.forEach(function (elem) {\n    result += formatListItem(prefix, elem, fn, options);\n  });\n  return result + '\\n';\n}\nfunction formatOrderedList(elem, fn, options) {\n  var result = '';\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function (child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  });\n  // Return different functions for different OL types\n  var typeFunction = function () {\n    // Determine type\n    var olType = elem.attribs.type || '1';\n    // TODO Imeplement the other valid types\n    //   Fallback to type '1' function for other valid types\n    switch (olType) {\n      case 'a':\n        return function (start, i) {\n          return String.fromCharCode(i + start + 97);\n        };\n      case 'A':\n        return function (start, i) {\n          return String.fromCharCode(i + start + 65);\n        };\n      case '1':\n      default:\n        return function (start, i) {\n          return i + 1 + start;\n        };\n    }\n  }();\n  // Make sure there are list items present\n  if (nonWhiteSpaceChildren.length) {\n    // Calculate initial start from ol attribute\n    var start = Number(elem.attribs.start || '1') - 1;\n    // Calculate the maximum length to i.\n    var maxLength = (nonWhiteSpaceChildren.length + start).toString().length;\n    nonWhiteSpaceChildren.forEach(function (elem, i) {\n      // Use different function depending on type\n      var index = typeFunction(start, i);\n      // Calculate the needed spacing for nice indentation.\n      var spacing = maxLength - index.toString().length;\n      var prefix = ' ' + index + '. ' + ' '.repeat(spacing);\n      result += formatListItem(prefix, elem, fn, options);\n    });\n  }\n  return result + '\\n';\n}\nfunction tableToString(table) {\n  // Determine space width per column\n  // Convert all rows to lengths\n  var widths = table.map(function (row) {\n    return row.map(function (col) {\n      return col.length;\n    });\n  });\n  // Invert rows with colums\n  widths = helper.arrayZip(widths);\n  // Determine the max values for each column\n  widths = widths.map(function (col) {\n    return max(col);\n  });\n\n  // Build the table\n  var text = '';\n  table.forEach(function (row) {\n    var i = 0;\n    row.forEach(function (col) {\n      text += padEnd(col.trim(), widths[i++], ' ') + '   ';\n    });\n    text += '\\n';\n  });\n  return text + '\\n';\n}\nfunction formatTable(elem, fn, options) {\n  var table = [];\n  elem.children.forEach(tryParseRows);\n  return tableToString(table);\n  function tryParseRows(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n    switch (elem.name.toLowerCase()) {\n      case \"thead\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"center\":\n        elem.children.forEach(tryParseRows);\n        return;\n      case 'tr':\n        var rows = [];\n        elem.children.forEach(function (elem) {\n          var tokens, count;\n          if (elem.type === 'tag') {\n            switch (elem.name.toLowerCase()) {\n              case 'th':\n                tokens = formatHeading(elem, fn, options).split('\\n');\n                rows.push(compact(tokens));\n                break;\n              case 'td':\n                tokens = fn(elem.children, options).split('\\n');\n                rows.push(compact(tokens));\n                // Fill colspans with empty values\n                if (elem.attribs && elem.attribs.colspan) {\n                  count = elem.attribs.colspan - 1 || 0;\n                  times(count, function () {\n                    rows.push(['']);\n                  });\n                }\n                break;\n            }\n          }\n        });\n        rows = helper.arrayZip(rows);\n        rows.forEach(function (row) {\n          row = row.map(function (col) {\n            return col || '';\n          });\n          table.push(row);\n        });\n        break;\n    }\n  }\n}\nfunction formatBlockquote(elem, fn, options) {\n  return '> ' + fn(elem.children, options) + '\\n';\n}\nexports.text = formatText;\nexports.image = formatImage;\nexports.lineBreak = formatLineBreak;\nexports.paragraph = formatParagraph;\nexports.anchor = formatAnchor;\nexports.heading = formatHeading;\nexports.table = formatTable;\nexports.orderedList = formatOrderedList;\nexports.unorderedList = formatUnorderedList;\nexports.listItem = formatListItem;\nexports.horizontalLine = formatHorizontalLine;\nexports.blockquote = formatBlockquote;","map":{"version":3,"names":["max","require","compact","times","trimStart","padEnd","he","helper","formatText","elem","options","text","data","decode","decodeOptions","isInPre","wordwrap","trimLeadingSpace","formatImage","ignoreImage","result","attribs","alt","src","formatLineBreak","fn","children","formatParagraph","paragraph","singleNewLineParagraphs","formatHeading","heading","uppercaseHeadings","toUpperCase","formatAnchor","href","storedCharCount","lineCharCount","ignoreHref","replace","noAnchorUrl","linkHrefBaseUrl","indexOf","hideLinkHrefIfSameAsText","replaceAll","noLinkBrackets","formatHorizontalLine","repeat","formatListItem","prefix","Object","assign","length","whiteSpaceRegex","formatUnorderedList","unorderedListItemPrefix","nonWhiteSpaceChildren","filter","child","type","test","forEach","formatOrderedList","typeFunction","olType","start","i","String","fromCharCode","Number","maxLength","toString","index","spacing","tableToString","table","widths","map","row","col","arrayZip","trim","formatTable","tryParseRows","name","toLowerCase","rows","tokens","count","split","push","colspan","formatBlockquote","exports","image","lineBreak","anchor","orderedList","unorderedList","listItem","horizontalLine","blockquote"],"sources":["C:/Users/Microsoft/OneDrive/Documents/c prgramming/.dist/react js/songProject/my-app/node_modules/html-to-text/lib/formatter.js"],"sourcesContent":["var max = require('lodash/max');\nvar compact = require('lodash/compact');\nvar times = require('lodash/times');\n\nvar trimStart = require('lodash/trimStart');\nvar padEnd = require('lodash/padEnd');\n\nvar he = require('he');\n\nvar helper = require('./helper');\n\nfunction formatText(elem, options) {\n  var text = elem.data || \"\";\n  text = he.decode(text, options.decodeOptions);\n\n  if (options.isInPre) {\n    return text;\n  } else {\n    return helper.wordwrap(elem.trimLeadingSpace ? trimStart(text) : text, options);\n  }\n}\n\nfunction formatImage(elem, options) {\n  if (options.ignoreImage) {\n    return '';\n  }\n\n  var result = '', attribs = elem.attribs || {};\n  if (attribs.alt) {\n    result += he.decode(attribs.alt, options.decodeOptions);\n    if (attribs.src) {\n      result += ' ';\n    }\n  }\n  if (attribs.src) {\n    result += '[' + attribs.src + ']';\n  }\n  return (result);\n}\n\nfunction formatLineBreak(elem, fn, options) {\n  return '\\n' + fn(elem.children, options);\n}\n\nfunction formatParagraph(elem, fn, options) {\n  var paragraph = fn(elem.children, options);\n  if (options.singleNewLineParagraphs) {\n    return paragraph + '\\n';\n  } else {\n    return paragraph + '\\n\\n';\n  }\n}\n\nfunction formatHeading(elem, fn, options) {\n  var heading = fn(elem.children, options);\n  if (options.uppercaseHeadings) {\n    heading = heading.toUpperCase();\n  }\n  return heading + '\\n';\n}\n\n// If we have both href and anchor text, format it in a useful manner:\n// - \"anchor text [href]\"\n// Otherwise if we have only anchor text or an href, we return the part we have:\n// - \"anchor text\" or\n// - \"href\"\nfunction formatAnchor(elem, fn, options) {\n  var href = '';\n  // Always get the anchor text\n  var storedCharCount = options.lineCharCount;\n  var text = fn(elem.children || [], options);\n  if (!text) {\n    text = '';\n  }\n\n  var result = elem.trimLeadingSpace ? trimStart(text) : text;\n\n  if (!options.ignoreHref) {\n    // Get the href, if present\n    if (elem.attribs && elem.attribs.href) {\n      href = elem.attribs.href.replace(/^mailto:/, '');\n    }\n    if (href) {\n      if ((!options.noAnchorUrl) || (options.noAnchorUrl && href[0] !== '#')) {\n        if (options.linkHrefBaseUrl && href.indexOf('/') === 0) {\n          href = options.linkHrefBaseUrl + href;\n        }\n        if (!options.hideLinkHrefIfSameAsText || href !== helper.replaceAll(result, '\\n', '')) {\n          if (!options.noLinkBrackets) {\n            result += ' [' + href + ']';\n          } else {\n            result += ' ' + href;\n          }\n        }\n      }\n    }\n  }\n\n  options.lineCharCount = storedCharCount;\n\n  return formatText({ data: result || href, trimLeadingSpace: elem.trimLeadingSpace }, options);\n}\n\nfunction formatHorizontalLine(elem, fn, options) {\n  return '\\n' + '-'.repeat(options.wordwrap) + '\\n\\n';\n}\n\nfunction formatListItem(prefix, elem, fn, options) {\n  options = Object.assign({}, options);\n  // Reduce the wordwrap for sub elements.\n  if (options.wordwrap) {\n    options.wordwrap -= prefix.length;\n  }\n  // Process sub elements.\n  var text = fn(elem.children, options);\n  // Replace all line breaks with line break + prefix spacing.\n  text = text.replace(/\\n/g, '\\n' + ' '.repeat(prefix.length));\n  // Add first prefix and line break at the end.\n  return prefix + text + '\\n';\n}\n\nvar whiteSpaceRegex = /^\\s*$/;\n\nfunction formatUnorderedList(elem, fn, options) {\n  var result = '';\n  var prefix = options.unorderedListItemPrefix;\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function(child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  });\n  nonWhiteSpaceChildren.forEach(function(elem) {\n    result += formatListItem(prefix, elem, fn, options);\n  });\n  return result + '\\n';\n}\n\nfunction formatOrderedList(elem, fn, options) {\n  var result = '';\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function(child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  });\n  // Return different functions for different OL types\n  var typeFunction = (function() {\n    // Determine type\n    var olType = elem.attribs.type || '1';\n    // TODO Imeplement the other valid types\n    //   Fallback to type '1' function for other valid types\n    switch(olType) {\n      case 'a': return function(start, i) { return String.fromCharCode(i + start + 97);};\n      case 'A': return function(start, i) { return String.fromCharCode(i + start + 65);};\n      case '1':\n      default: return function(start, i) { return i + 1 + start;};\n    }\n  }());\n  // Make sure there are list items present\n  if (nonWhiteSpaceChildren.length) {\n    // Calculate initial start from ol attribute\n    var start = Number(elem.attribs.start || '1') - 1;\n    // Calculate the maximum length to i.\n    var maxLength = (nonWhiteSpaceChildren.length + start).toString().length;\n    nonWhiteSpaceChildren.forEach(function(elem, i) {\n      // Use different function depending on type\n      var index = typeFunction(start, i);\n      // Calculate the needed spacing for nice indentation.\n      var spacing = maxLength - index.toString().length;\n      var prefix = ' ' + index + '. ' + ' '.repeat(spacing);\n      result += formatListItem(prefix, elem, fn, options);\n    });\n  }\n  return result + '\\n';\n}\n\nfunction tableToString(table) {\n  // Determine space width per column\n  // Convert all rows to lengths\n  var widths = table.map(function(row) {\n    return row.map(function(col) {\n      return col.length;\n    });\n  });\n  // Invert rows with colums\n  widths = helper.arrayZip(widths);\n  // Determine the max values for each column\n  widths = widths.map(function(col) {\n    return max(col);\n  });\n\n  // Build the table\n  var text = '';\n  table.forEach(function(row) {\n    var i = 0;\n    row.forEach(function(col) {\n      text += padEnd(col.trim(), widths[i++], ' ') + '   ';\n    });\n    text += '\\n';\n  });\n  return text + '\\n';\n}\n\nfunction formatTable(elem, fn, options) {\n  var table = [];\n  elem.children.forEach(tryParseRows);\n  return tableToString(table);\n\n  function tryParseRows(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n    switch (elem.name.toLowerCase()) {\n      case \"thead\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"center\":\n        elem.children.forEach(tryParseRows);\n        return;\n\n      case 'tr':\n        var rows = [];\n        elem.children.forEach(function(elem) {\n          var tokens, count;\n          if (elem.type === 'tag') {\n            switch (elem.name.toLowerCase()) {\n              case 'th':\n                tokens = formatHeading(elem, fn, options).split('\\n');\n                rows.push(compact(tokens));\n                break;\n\n              case 'td':\n                tokens = fn(elem.children, options).split('\\n');\n                rows.push(compact(tokens));\n                // Fill colspans with empty values\n                if (elem.attribs && elem.attribs.colspan) {\n                  count = elem.attribs.colspan - 1 || 0;\n                  times(count, function() {\n                    rows.push(['']);\n                  });\n                }\n                break;\n            }\n          }\n        });\n        rows = helper.arrayZip(rows);\n        rows.forEach(function(row) {\n          row = row.map(function(col) {\n            return col || '';\n          });\n          table.push(row);\n        });\n        break;\n    }\n  }\n}\n\nfunction formatBlockquote(elem, fn, options) {\n  return '> ' + fn(elem.children, options) + '\\n';\n}\n\nexports.text = formatText;\nexports.image = formatImage;\nexports.lineBreak = formatLineBreak;\nexports.paragraph = formatParagraph;\nexports.anchor = formatAnchor;\nexports.heading = formatHeading;\nexports.table = formatTable;\nexports.orderedList = formatOrderedList;\nexports.unorderedList = formatUnorderedList;\nexports.listItem = formatListItem;\nexports.horizontalLine = formatHorizontalLine;\nexports.blockquote = formatBlockquote;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}