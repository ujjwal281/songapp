{"ast":null,"code":"var zip = require('lodash/zip');\nvar trimEnd = require('lodash/trimEnd');\n\n// Split a long word up to fit within the word wrap limit.  Use either a\n// character to split looking back from the word wrap limit, or\n// truncate to the word wrap limit.\nfunction splitLongWord(word, options) {\n  var wrapCharacters = options.longWordSplit.wrapCharacters || [];\n  var forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;\n  var max = options.wordwrap;\n  var fuseWord = [];\n  var idx = 0;\n  while (word.length > max) {\n    var firstLine = word.substr(0, max);\n    var remainingChars = word.substr(max);\n    var splitIndex = firstLine.lastIndexOf(wrapCharacters[idx]);\n    if (splitIndex > -1) {\n      // We've found a character to split on, store before the split then check if we\n      // need to split again\n      word = firstLine.substr(splitIndex + 1) + remainingChars;\n      fuseWord.push(firstLine.substr(0, splitIndex + 1));\n    } else {\n      idx++;\n      if (idx >= wrapCharacters.length) {\n        // Cannot split on character, so either split at 'max' or preserve length\n        if (forceWrapOnLimit) {\n          fuseWord.push(firstLine);\n          word = remainingChars;\n          if (word.length > max) {\n            continue;\n          }\n        } else {\n          word = firstLine + remainingChars;\n          if (!options.preserveNewlines) {\n            word += '\\n';\n          }\n        }\n        break;\n      } else {\n        word = firstLine + remainingChars;\n      }\n    }\n  }\n  fuseWord.push(word);\n  return fuseWord.join('\\n');\n}\nexports.wordwrap = function wordwrap(text, options) {\n  var max = options.wordwrap;\n  var preserveNewlines = options.preserveNewlines;\n  var length = options.lineCharCount;\n\n  // Preserve leading space\n  var result = text.startsWith(' ') ? ' ' : '';\n  length += result.length;\n  var buffer = [];\n  // Split the text into words, decide to preserve new lines or not.\n  var words = preserveNewlines ? text.trim().replace(/\\n/g, '\\n ').split(/\\ +/) : text.trim().split(/\\s+/);\n\n  // Determine where to end line word by word.\n  words.forEach(function (word) {\n    // Add buffer to result if we can't fit any more words in the buffer.\n    if ((max || max === 0) && length > 0 && (length + word.length > max || length + word.indexOf('\\n') > max)) {\n      // Concat buffer and add it to the result\n      result += buffer.join(' ') + '\\n';\n      // Reset buffer and length\n      buffer.length = length = 0;\n    }\n\n    // Check if the current word is long enough to be wrapped\n    if ((max || max === 0) && options.longWordSplit && word.length > max) {\n      word = splitLongWord(word, options);\n    }\n    buffer.push(word);\n\n    // If the word contains a newline then restart the count and add the buffer to the result\n    if (word.indexOf('\\n') !== -1) {\n      result += buffer.join(' ');\n\n      // Reset the buffer, let the length include any characters after the last newline\n      buffer.length = 0;\n      length = word.length - (word.lastIndexOf('\\n') + 1);\n      // If there are characters after the newline, add a space and increase the length by 1\n      if (length) {\n        result += ' ';\n        length++;\n      }\n    } else {\n      // Add word length + one whitespace\n      length += word.length + 1;\n    }\n  });\n  // Add the rest to the result.\n  result += buffer.join(' ');\n\n  // Preserve trailing space\n  if (!text.endsWith(' ')) {\n    result = trimEnd(result);\n  } else if (!result.endsWith(' ')) {\n    result = result + ' ';\n  }\n  return result;\n};\nexports.arrayZip = function arrayZip(array) {\n  return zip.apply(null, array);\n};\nexports.splitCssSearchTag = function splitCssSearchTag(tagString) {\n  function getParams(re, string) {\n    var captures = [],\n      found;\n    while ((found = re.exec(string)) !== null) {\n      captures.push(found[1]);\n    }\n    return captures;\n  }\n  var splitTag = {};\n  var elementRe = /(^\\w*)/g;\n  splitTag.element = elementRe.exec(tagString)[1];\n  splitTag.classes = getParams(/\\.([\\d\\w-]*)/g, tagString);\n  splitTag.ids = getParams(/#([\\d\\w-]*)/g, tagString);\n  return splitTag;\n};\nexports.replaceAll = function replaceAll(str, find, replace) {\n  var reg = new RegExp(find, 'g');\n  return str.replace(reg, replace);\n};","map":{"version":3,"names":["zip","require","trimEnd","splitLongWord","word","options","wrapCharacters","longWordSplit","forceWrapOnLimit","max","wordwrap","fuseWord","idx","length","firstLine","substr","remainingChars","splitIndex","lastIndexOf","push","preserveNewlines","join","exports","text","lineCharCount","result","startsWith","buffer","words","trim","replace","split","forEach","indexOf","endsWith","arrayZip","array","apply","splitCssSearchTag","tagString","getParams","re","string","captures","found","exec","splitTag","elementRe","element","classes","ids","replaceAll","str","find","reg","RegExp"],"sources":["C:/Users/Microsoft/OneDrive/Documents/c prgramming/.dist/react js/songProject/my-app/node_modules/html-to-text/lib/helper.js"],"sourcesContent":["var zip = require('lodash/zip');\nvar trimEnd = require('lodash/trimEnd');\n\n// Split a long word up to fit within the word wrap limit.  Use either a\n// character to split looking back from the word wrap limit, or\n// truncate to the word wrap limit.\nfunction splitLongWord(word, options) {\n  var wrapCharacters = options.longWordSplit.wrapCharacters || [];\n  var forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;\n  var max = options.wordwrap;\n\n  var fuseWord = [];\n  var idx = 0;\n  while (word.length > max) {\n    var firstLine = word.substr(0, max);\n    var remainingChars = word.substr(max);\n\n    var splitIndex = firstLine.lastIndexOf(wrapCharacters[idx]);\n\n    if (splitIndex > -1) {\n      // We've found a character to split on, store before the split then check if we\n      // need to split again\n      word = firstLine.substr(splitIndex + 1) + remainingChars;\n      fuseWord.push(firstLine.substr(0, splitIndex + 1));\n    } else {\n      idx++;\n      if (idx >= wrapCharacters.length) {\n        // Cannot split on character, so either split at 'max' or preserve length\n        if (forceWrapOnLimit) {\n          fuseWord.push(firstLine);\n          word = remainingChars;\n          if (word.length > max) {\n            continue;\n          }\n        } else {\n          word = firstLine + remainingChars;\n          if (!options.preserveNewlines) {\n            word += '\\n';\n          }\n        }\n        break;\n      } else {\n        word = firstLine + remainingChars;\n      }\n    }\n  }\n  fuseWord.push(word);\n\n  return fuseWord.join('\\n');\n}\n\nexports.wordwrap = function wordwrap(text, options) {\n  var max = options.wordwrap;\n  var preserveNewlines = options.preserveNewlines;\n  var length = options.lineCharCount;\n\n  // Preserve leading space\n  var result = text.startsWith(' ') ? ' ' : '';\n  length += result.length;\n  var buffer = [];\n  // Split the text into words, decide to preserve new lines or not.\n  var words = preserveNewlines\n    ? text.trim().replace(/\\n/g, '\\n ').split(/\\ +/)\n    : text.trim().split(/\\s+/);\n\n  // Determine where to end line word by word.\n  words.forEach(function(word) {\n    // Add buffer to result if we can't fit any more words in the buffer.\n    if ((max || max === 0) && length > 0 && ((length + word.length > max) || (length + word.indexOf('\\n') > max))) {\n      // Concat buffer and add it to the result\n      result += buffer.join(' ') + '\\n';\n      // Reset buffer and length\n      buffer.length = length = 0;\n    }\n\n    // Check if the current word is long enough to be wrapped\n    if ((max || max === 0) && (options.longWordSplit) && (word.length > max)) {\n      word = splitLongWord(word, options);\n    }\n\n    buffer.push(word);\n\n    // If the word contains a newline then restart the count and add the buffer to the result\n    if (word.indexOf('\\n') !== -1) {\n      result += buffer.join(' ');\n\n      // Reset the buffer, let the length include any characters after the last newline\n      buffer.length = 0;\n      length = word.length - (word.lastIndexOf('\\n') + 1);\n      // If there are characters after the newline, add a space and increase the length by 1\n      if (length) {\n        result += ' ';\n        length++;\n      }\n    } else {\n      // Add word length + one whitespace\n      length += word.length + 1;\n    }\n  });\n  // Add the rest to the result.\n  result += buffer.join(' ');\n\n  // Preserve trailing space\n  if (!text.endsWith(' ')) {\n    result = trimEnd(result);\n  } else if (!result.endsWith(' ')) {\n    result = result + ' ';\n  }\n\n  return result;\n};\n\nexports.arrayZip = function arrayZip(array) {\n  return zip.apply(null, array);\n};\n\nexports.splitCssSearchTag = function splitCssSearchTag(tagString) {\n  function getParams(re, string) {\n    var captures = [], found;\n    while ((found = re.exec(string)) !== null) {\n      captures.push(found[1]);\n    }\n    return captures;\n  }\n\n  var splitTag = {};\n  var elementRe = /(^\\w*)/g;\n  splitTag.element = elementRe.exec(tagString)[1];\n  splitTag.classes = getParams( /\\.([\\d\\w-]*)/g, tagString);\n  splitTag.ids = getParams( /#([\\d\\w-]*)/g, tagString);\n\n  return splitTag;\n};\n\nexports.replaceAll = function replaceAll(str, find, replace) {\n  var reg = new RegExp(find, 'g');\n\n  return str.replace(reg, replace);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}