{"ast":null,"code":"var includes = require('lodash/includes');\nvar trimEnd = require('lodash/trimEnd');\nvar htmlparser = require('htmlparser2');\nvar helper = require('./helper');\nvar defaultFormat = require('./formatter');\n\n// Which type of tags should not be parsed\nvar SKIP_TYPES = ['style', 'script'];\nfunction htmlToText(html, options) {\n  options = Object.assign({\n    wordwrap: 80,\n    tables: [],\n    preserveNewlines: false,\n    uppercaseHeadings: true,\n    singleNewLineParagraphs: false,\n    hideLinkHrefIfSameAsText: false,\n    linkHrefBaseUrl: null,\n    noLinkBrackets: false,\n    noAnchorUrl: true,\n    baseElement: 'body',\n    returnDomByDefault: true,\n    format: {},\n    decodeOptions: {\n      isAttributeValue: false,\n      strict: false\n    },\n    longWordSplit: {\n      wrapCharacters: [],\n      forceWrapOnLimit: false\n    },\n    unorderedListItemPrefix: ' * '\n  }, options || {});\n  var handler = new htmlparser.DefaultHandler(function (error, dom) {}, {\n    verbose: true\n  });\n  new htmlparser.Parser(handler).parseComplete(html);\n  options.lineCharCount = 0;\n  var result = '';\n  var baseElements = Array.isArray(options.baseElement) ? options.baseElement : [options.baseElement];\n  for (var idx = 0; idx < baseElements.length; ++idx) {\n    result += walk(filterBody(handler.dom, options, baseElements[idx]), options);\n  }\n  return trimEnd(result);\n}\nfunction filterBody(dom, options, baseElement) {\n  var result = null;\n  var splitTag = helper.splitCssSearchTag(baseElement);\n  function walk(dom) {\n    if (result) return;\n    dom.forEach(function (elem) {\n      if (result) return;\n      if (elem.name === splitTag.element) {\n        var documentClasses = elem.attribs && elem.attribs.class ? elem.attribs.class.split(\" \") : [];\n        var documentIds = elem.attribs && elem.attribs.id ? elem.attribs.id.split(\" \") : [];\n        if (splitTag.classes.every(function (val) {\n          return documentClasses.indexOf(val) >= 0;\n        }) && splitTag.ids.every(function (val) {\n          return documentIds.indexOf(val) >= 0;\n        })) {\n          result = [elem];\n          return;\n        }\n      }\n      if (elem.children) walk(elem.children);\n    });\n  }\n  walk(dom);\n  return options.returnDomByDefault ? result || dom : result;\n}\nfunction containsTable(attr, tables) {\n  if (tables === true) return true;\n  function removePrefix(key) {\n    return key.substr(1);\n  }\n  function checkPrefix(prefix) {\n    return function (key) {\n      return key.startsWith(prefix);\n    };\n  }\n  function filterByPrefix(tables, prefix) {\n    return tables.filter(checkPrefix(prefix)).map(removePrefix);\n  }\n  var classes = filterByPrefix(tables, '.');\n  var ids = filterByPrefix(tables, '#');\n  return attr && (includes(classes, attr['class']) || includes(ids, attr['id']));\n}\nfunction walk(dom, options, result) {\n  if (arguments.length < 3) {\n    result = '';\n  }\n  var whiteSpaceRegex = /\\s$/;\n  var format = Object.assign({}, defaultFormat, options.format);\n  if (!dom) {\n    return result;\n  }\n  dom.forEach(function (elem) {\n    switch (elem.type) {\n      case 'tag':\n        switch (elem.name.toLowerCase()) {\n          case 'img':\n            result += format.image(elem, options);\n            break;\n          case 'a':\n            // Inline element needs its leading space to be trimmed if `result`\n            // currently ends with whitespace\n            elem.trimLeadingSpace = whiteSpaceRegex.test(result);\n            result += format.anchor(elem, walk, options);\n            break;\n          case 'p':\n            result += format.paragraph(elem, walk, options);\n            break;\n          case 'h1':\n          case 'h2':\n          case 'h3':\n          case 'h4':\n          case 'h5':\n          case 'h6':\n            result += format.heading(elem, walk, options);\n            break;\n          case 'br':\n            result += format.lineBreak(elem, walk, options);\n            break;\n          case 'hr':\n            result += format.horizontalLine(elem, walk, options);\n            break;\n          case 'ul':\n            result += format.unorderedList(elem, walk, options);\n            break;\n          case 'ol':\n            result += format.orderedList(elem, walk, options);\n            break;\n          case 'pre':\n            var newOptions = Object.assign({}, options);\n            newOptions.isInPre = true;\n            result += format.paragraph(elem, walk, newOptions);\n            break;\n          case 'table':\n            result = containsTable(elem.attribs, options.tables) ? result + format.table(elem, walk, options) : walk(elem.children || [], options, result);\n            break;\n          case 'blockquote':\n            result += format.blockquote(elem, walk, options);\n            break;\n          default:\n            result = walk(elem.children || [], options, result);\n        }\n        break;\n      case 'text':\n        if (elem.data !== '\\r\\n') {\n          // Text needs its leading space to be trimmed if `result`\n          // currently ends with whitespace\n          elem.trimLeadingSpace = whiteSpaceRegex.test(result);\n          result += format.text(elem, options);\n        }\n        break;\n      default:\n        if (!includes(SKIP_TYPES, elem.type)) {\n          result = walk(elem.children || [], options, result);\n        }\n    }\n    options.lineCharCount = result.length - (result.lastIndexOf('\\n') + 1);\n  });\n  return result;\n}\nexports.fromString = function (str, options) {\n  return htmlToText(str, options || {});\n};","map":{"version":3,"names":["includes","require","trimEnd","htmlparser","helper","defaultFormat","SKIP_TYPES","htmlToText","html","options","Object","assign","wordwrap","tables","preserveNewlines","uppercaseHeadings","singleNewLineParagraphs","hideLinkHrefIfSameAsText","linkHrefBaseUrl","noLinkBrackets","noAnchorUrl","baseElement","returnDomByDefault","format","decodeOptions","isAttributeValue","strict","longWordSplit","wrapCharacters","forceWrapOnLimit","unorderedListItemPrefix","handler","DefaultHandler","error","dom","verbose","Parser","parseComplete","lineCharCount","result","baseElements","Array","isArray","idx","length","walk","filterBody","splitTag","splitCssSearchTag","forEach","elem","name","element","documentClasses","attribs","class","split","documentIds","id","classes","every","val","indexOf","ids","children","containsTable","attr","removePrefix","key","substr","checkPrefix","prefix","startsWith","filterByPrefix","filter","map","arguments","whiteSpaceRegex","type","toLowerCase","image","trimLeadingSpace","test","anchor","paragraph","heading","lineBreak","horizontalLine","unorderedList","orderedList","newOptions","isInPre","table","blockquote","data","text","lastIndexOf","exports","fromString","str"],"sources":["C:/Users/Microsoft/OneDrive/Documents/c prgramming/.dist/react js/songProject/my-app/node_modules/html-to-text/lib/html-to-text.js"],"sourcesContent":["var includes = require('lodash/includes');\nvar trimEnd = require('lodash/trimEnd');\nvar htmlparser = require('htmlparser2');\n\nvar helper = require('./helper');\nvar defaultFormat = require('./formatter');\n\n// Which type of tags should not be parsed\nvar SKIP_TYPES = [\n  'style',\n  'script'\n];\n\nfunction htmlToText(html, options) {\n  options = Object.assign({\n    wordwrap: 80,\n    tables: [],\n    preserveNewlines: false,\n    uppercaseHeadings: true,\n    singleNewLineParagraphs: false,\n    hideLinkHrefIfSameAsText: false,\n    linkHrefBaseUrl: null,\n    noLinkBrackets: false,\n    noAnchorUrl: true,\n    baseElement: 'body',\n    returnDomByDefault: true,\n    format: {},\n    decodeOptions: {\n      isAttributeValue: false,\n      strict: false\n    },\n    longWordSplit: {\n      wrapCharacters: [],\n      forceWrapOnLimit: false\n    },\n    unorderedListItemPrefix: ' * '\n  }, options || {});\n\n  var handler = new htmlparser.DefaultHandler(function (error, dom) {\n\n  }, {\n    verbose: true\n  });\n  new htmlparser.Parser(handler).parseComplete(html);\n\n  options.lineCharCount = 0;\n\n  var result = '';\n  var baseElements = Array.isArray(options.baseElement) ? options.baseElement : [options.baseElement];\n  for (var idx = 0; idx < baseElements.length; ++idx) {\n    result += walk(filterBody(handler.dom, options, baseElements[idx]), options);\n  }\n  return trimEnd(result);\n}\n\nfunction filterBody(dom, options, baseElement) {\n  var result = null;\n\n  var splitTag = helper.splitCssSearchTag(baseElement);\n\n  function walk(dom) {\n    if (result) return;\n    dom.forEach(function(elem) {\n      if (result) return;\n      if (elem.name === splitTag.element) {\n        var documentClasses = elem.attribs && elem.attribs.class ? elem.attribs.class.split(\" \") : [];\n        var documentIds = elem.attribs && elem.attribs.id ? elem.attribs.id.split(\" \") : [];\n\n        if ((splitTag.classes.every(function (val) { return documentClasses.indexOf(val) >= 0; })) &&\n          (splitTag.ids.every(function (val) { return documentIds.indexOf(val) >= 0; }))) {\n          result = [elem];\n          return;\n        }\n      }\n      if (elem.children) walk(elem.children);\n    });\n  }\n  walk(dom);\n  return options.returnDomByDefault ? result || dom : result;\n}\n\nfunction containsTable(attr, tables) {\n  if (tables === true) return true;\n\n  function removePrefix(key) {\n    return key.substr(1);\n  }\n  function checkPrefix(prefix) {\n    return function(key) {\n      return key.startsWith(prefix);\n    };\n  }\n  function filterByPrefix(tables, prefix) {\n    return tables\n      .filter(checkPrefix(prefix))\n      .map(removePrefix);\n  }\n  var classes = filterByPrefix(tables, '.');\n  var ids = filterByPrefix(tables, '#');\n  return attr && (includes(classes, attr['class']) || includes(ids, attr['id']));\n}\n\nfunction walk(dom, options, result) {\n  if (arguments.length < 3) {\n    result = '';\n  }\n  var whiteSpaceRegex = /\\s$/;\n  var format = Object.assign({}, defaultFormat, options.format);\n\n  if (!dom) {\n    return result;\n  }\n\n  dom.forEach(function(elem) {\n    switch(elem.type) {\n      case 'tag':\n        switch(elem.name.toLowerCase()) {\n          case 'img':\n            result += format.image(elem, options);\n            break;\n          case 'a':\n            // Inline element needs its leading space to be trimmed if `result`\n            // currently ends with whitespace\n            elem.trimLeadingSpace = whiteSpaceRegex.test(result);\n            result += format.anchor(elem, walk, options);\n            break;\n          case 'p':\n            result += format.paragraph(elem, walk, options);\n            break;\n          case 'h1':\n          case 'h2':\n          case 'h3':\n          case 'h4':\n          case 'h5':\n          case 'h6':\n            result += format.heading(elem, walk, options);\n            break;\n          case 'br':\n            result += format.lineBreak(elem, walk, options);\n            break;\n          case 'hr':\n            result += format.horizontalLine(elem, walk, options);\n            break;\n          case 'ul':\n            result += format.unorderedList(elem, walk, options);\n            break;\n          case 'ol':\n            result += format.orderedList(elem, walk, options);\n            break;\n          case 'pre':\n            var newOptions = Object.assign({}, options);\n            newOptions.isInPre = true;\n            result += format.paragraph(elem, walk, newOptions);\n            break;\n          case 'table':\n            result = containsTable(elem.attribs, options.tables)\n              ? result + format.table(elem, walk, options)\n              : walk(elem.children || [], options, result);\n            break;\n          case 'blockquote':\n            result += format.blockquote(elem, walk, options);\n            break;\n          default:\n            result = walk(elem.children || [], options, result);\n        }\n        break;\n      case 'text':\n        if (elem.data !== '\\r\\n') {\n          // Text needs its leading space to be trimmed if `result`\n          // currently ends with whitespace\n          elem.trimLeadingSpace = whiteSpaceRegex.test(result);\n          result += format.text(elem, options);\n        }\n        break;\n      default:\n        if (!includes(SKIP_TYPES, elem.type)) {\n          result = walk(elem.children || [], options, result);\n        }\n    }\n\n    options.lineCharCount = result.length - (result.lastIndexOf('\\n') + 1);\n  });\n  return result;\n}\n\nexports.fromString = function(str, options) {\n  return htmlToText(str, options || {});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}