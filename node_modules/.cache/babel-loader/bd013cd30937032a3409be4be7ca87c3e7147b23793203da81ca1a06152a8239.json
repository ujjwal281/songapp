{"ast":null,"code":"import restArguments from './restArguments.js';\nimport now from './now.js';\n\n// When a sequence of calls of the returned function ends, the argument\n// function is triggered. The end of a sequence is defined by the `wait`\n// parameter. If `immediate` is passed, the argument function will be\n// triggered at the beginning of the sequence instead of at the end.\nexport default function debounce(func, wait, immediate) {\n  var timeout, previous, args, result, context;\n  var later = function () {\n    var passed = now() - previous;\n    if (wait > passed) {\n      timeout = setTimeout(later, wait - passed);\n    } else {\n      timeout = null;\n      if (!immediate) result = func.apply(context, args);\n      // This check is needed because `func` can recursively invoke `debounced`.\n      if (!timeout) args = context = null;\n    }\n  };\n  var debounced = restArguments(function (_args) {\n    context = this;\n    args = _args;\n    previous = now();\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n      if (immediate) result = func.apply(context, args);\n    }\n    return result;\n  });\n  debounced.cancel = function () {\n    clearTimeout(timeout);\n    timeout = args = context = null;\n  };\n  return debounced;\n}","map":{"version":3,"names":["restArguments","now","debounce","func","wait","immediate","timeout","previous","args","result","context","later","passed","setTimeout","apply","debounced","_args","cancel","clearTimeout"],"sources":["C:/Users/Microsoft/OneDrive/Documents/c prgramming/.dist/react js/songProject/my-app/node_modules/underscore/modules/debounce.js"],"sourcesContent":["import restArguments from './restArguments.js';\nimport now from './now.js';\n\n// When a sequence of calls of the returned function ends, the argument\n// function is triggered. The end of a sequence is defined by the `wait`\n// parameter. If `immediate` is passed, the argument function will be\n// triggered at the beginning of the sequence instead of at the end.\nexport default function debounce(func, wait, immediate) {\n  var timeout, previous, args, result, context;\n\n  var later = function() {\n    var passed = now() - previous;\n    if (wait > passed) {\n      timeout = setTimeout(later, wait - passed);\n    } else {\n      timeout = null;\n      if (!immediate) result = func.apply(context, args);\n      // This check is needed because `func` can recursively invoke `debounced`.\n      if (!timeout) args = context = null;\n    }\n  };\n\n  var debounced = restArguments(function(_args) {\n    context = this;\n    args = _args;\n    previous = now();\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n      if (immediate) result = func.apply(context, args);\n    }\n    return result;\n  });\n\n  debounced.cancel = function() {\n    clearTimeout(timeout);\n    timeout = args = context = null;\n  };\n\n  return debounced;\n}\n"],"mappings":"AAAA,OAAOA,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,GAAG,MAAM,UAAU;;AAE1B;AACA;AACA;AACA;AACA,eAAe,SAASC,QAAQA,CAACC,IAAI,EAAEC,IAAI,EAAEC,SAAS,EAAE;EACtD,IAAIC,OAAO,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,MAAM,EAAEC,OAAO;EAE5C,IAAIC,KAAK,GAAG,SAAAA,CAAA,EAAW;IACrB,IAAIC,MAAM,GAAGX,GAAG,CAAC,CAAC,GAAGM,QAAQ;IAC7B,IAAIH,IAAI,GAAGQ,MAAM,EAAE;MACjBN,OAAO,GAAGO,UAAU,CAACF,KAAK,EAAEP,IAAI,GAAGQ,MAAM,CAAC;IAC5C,CAAC,MAAM;MACLN,OAAO,GAAG,IAAI;MACd,IAAI,CAACD,SAAS,EAAEI,MAAM,GAAGN,IAAI,CAACW,KAAK,CAACJ,OAAO,EAAEF,IAAI,CAAC;MAClD;MACA,IAAI,CAACF,OAAO,EAAEE,IAAI,GAAGE,OAAO,GAAG,IAAI;IACrC;EACF,CAAC;EAED,IAAIK,SAAS,GAAGf,aAAa,CAAC,UAASgB,KAAK,EAAE;IAC5CN,OAAO,GAAG,IAAI;IACdF,IAAI,GAAGQ,KAAK;IACZT,QAAQ,GAAGN,GAAG,CAAC,CAAC;IAChB,IAAI,CAACK,OAAO,EAAE;MACZA,OAAO,GAAGO,UAAU,CAACF,KAAK,EAAEP,IAAI,CAAC;MACjC,IAAIC,SAAS,EAAEI,MAAM,GAAGN,IAAI,CAACW,KAAK,CAACJ,OAAO,EAAEF,IAAI,CAAC;IACnD;IACA,OAAOC,MAAM;EACf,CAAC,CAAC;EAEFM,SAAS,CAACE,MAAM,GAAG,YAAW;IAC5BC,YAAY,CAACZ,OAAO,CAAC;IACrBA,OAAO,GAAGE,IAAI,GAAGE,OAAO,GAAG,IAAI;EACjC,CAAC;EAED,OAAOK,SAAS;AAClB"},"metadata":{},"sourceType":"module","externalDependencies":[]}