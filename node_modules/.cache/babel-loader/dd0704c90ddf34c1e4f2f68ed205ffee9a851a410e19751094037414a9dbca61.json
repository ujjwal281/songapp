{"ast":null,"code":"module.exports = compile;\nvar BaseFuncs = require(\"boolbase\"),\n  trueFunc = BaseFuncs.trueFunc,\n  falseFunc = BaseFuncs.falseFunc;\n\n/*\n\treturns a function that checks if an elements index matches the given rule\n\thighly optimized to return the fastest solution\n*/\nfunction compile(parsed) {\n  var a = parsed[0],\n    b = parsed[1] - 1;\n\n  //when b <= 0, a*n won't be possible for any matches when a < 0\n  //besides, the specification says that no element is matched when a and b are 0\n  if (b < 0 && a <= 0) return falseFunc;\n\n  //when a is in the range -1..1, it matches any element (so only b is checked)\n  if (a === -1) return function (pos) {\n    return pos <= b;\n  };\n  if (a === 0) return function (pos) {\n    return pos === b;\n  };\n  //when b <= 0 and a === 1, they match any element\n  if (a === 1) return b < 0 ? trueFunc : function (pos) {\n    return pos >= b;\n  };\n\n  //when a > 0, modulo can be used to check if there is a match\n  var bMod = b % a;\n  if (bMod < 0) bMod += a;\n  if (a > 1) {\n    return function (pos) {\n      return pos >= b && pos % a === bMod;\n    };\n  }\n  a *= -1; //make `a` positive\n\n  return function (pos) {\n    return pos <= b && pos % a === bMod;\n  };\n}","map":{"version":3,"names":["module","exports","compile","BaseFuncs","require","trueFunc","falseFunc","parsed","a","b","pos","bMod"],"sources":["C:/Users/Microsoft/OneDrive/Documents/c prgramming/.dist/react js/songProject/my-app/node_modules/cheerio/node_modules/nth-check/compile.js"],"sourcesContent":["module.exports = compile;\n\nvar BaseFuncs = require(\"boolbase\"),\n    trueFunc  = BaseFuncs.trueFunc,\n    falseFunc = BaseFuncs.falseFunc;\n\n/*\n\treturns a function that checks if an elements index matches the given rule\n\thighly optimized to return the fastest solution\n*/\nfunction compile(parsed){\n\tvar a = parsed[0],\n\t    b = parsed[1] - 1;\n\n\t//when b <= 0, a*n won't be possible for any matches when a < 0\n\t//besides, the specification says that no element is matched when a and b are 0\n\tif(b < 0 && a <= 0) return falseFunc;\n\n\t//when a is in the range -1..1, it matches any element (so only b is checked)\n\tif(a ===-1) return function(pos){ return pos <= b; };\n\tif(a === 0) return function(pos){ return pos === b; };\n\t//when b <= 0 and a === 1, they match any element\n\tif(a === 1) return b < 0 ? trueFunc : function(pos){ return pos >= b; };\n\n\t//when a > 0, modulo can be used to check if there is a match\n\tvar bMod = b % a;\n\tif(bMod < 0) bMod += a;\n\n\tif(a > 1){\n\t\treturn function(pos){\n\t\t\treturn pos >= b && pos % a === bMod;\n\t\t};\n\t}\n\n\ta *= -1; //make `a` positive\n\n\treturn function(pos){\n\t\treturn pos <= b && pos % a === bMod;\n\t};\n}"],"mappings":"AAAAA,MAAM,CAACC,OAAO,GAAGC,OAAO;AAExB,IAAIC,SAAS,GAAGC,OAAO,CAAC,UAAU,CAAC;EAC/BC,QAAQ,GAAIF,SAAS,CAACE,QAAQ;EAC9BC,SAAS,GAAGH,SAAS,CAACG,SAAS;;AAEnC;AACA;AACA;AACA;AACA,SAASJ,OAAOA,CAACK,MAAM,EAAC;EACvB,IAAIC,CAAC,GAAGD,MAAM,CAAC,CAAC,CAAC;IACbE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC;;EAErB;EACA;EACA,IAAGE,CAAC,GAAG,CAAC,IAAID,CAAC,IAAI,CAAC,EAAE,OAAOF,SAAS;;EAEpC;EACA,IAAGE,CAAC,KAAI,CAAC,CAAC,EAAE,OAAO,UAASE,GAAG,EAAC;IAAE,OAAOA,GAAG,IAAID,CAAC;EAAE,CAAC;EACpD,IAAGD,CAAC,KAAK,CAAC,EAAE,OAAO,UAASE,GAAG,EAAC;IAAE,OAAOA,GAAG,KAAKD,CAAC;EAAE,CAAC;EACrD;EACA,IAAGD,CAAC,KAAK,CAAC,EAAE,OAAOC,CAAC,GAAG,CAAC,GAAGJ,QAAQ,GAAG,UAASK,GAAG,EAAC;IAAE,OAAOA,GAAG,IAAID,CAAC;EAAE,CAAC;;EAEvE;EACA,IAAIE,IAAI,GAAGF,CAAC,GAAGD,CAAC;EAChB,IAAGG,IAAI,GAAG,CAAC,EAAEA,IAAI,IAAIH,CAAC;EAEtB,IAAGA,CAAC,GAAG,CAAC,EAAC;IACR,OAAO,UAASE,GAAG,EAAC;MACnB,OAAOA,GAAG,IAAID,CAAC,IAAIC,GAAG,GAAGF,CAAC,KAAKG,IAAI;IACpC,CAAC;EACF;EAEAH,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;EAET,OAAO,UAASE,GAAG,EAAC;IACnB,OAAOA,GAAG,IAAID,CAAC,IAAIC,GAAG,GAAGF,CAAC,KAAKG,IAAI;EACpC,CAAC;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}